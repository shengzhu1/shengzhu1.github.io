<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git-stash]]></title>
    <url>%2F2019%2F06%2F05%2Fgit-stash%2F</url>
    <content type="text"><![CDATA[stash-暂存区1在处理其他事情时隐藏修改的地方,与stash相关的git区域：workspace、local 查看暂存1、git stash list123Demo结果显示如下：stash@&#123;0&#125;: On master: save with msgstash@&#123;1&#125;: WIP on master: ea810c8 add a.txt 2、git stash show [stash]12Demo显示如下：git stash show stash@&#123;0&#125; 3、git stash drop [stash]12Demo显示如下：git stash show stash@&#123;0&#125; 4、git stash clear1清除stash区域 从workspace添加到stash1、git stash save [msg] 123456workspace中的内容需要commit之后修改的才能进行save，默认git stash也会进行保存，使用git stash save [msg]可以带上提示信息，先后进行以下两个操作1、git stash 2、git stash save &quot;save with msg&quot;使用git stash list显示如下stash@&#123;0&#125;: On master: save with msgstash@&#123;1&#125;: WIP on master: ea810c8 add a.txt 猜想：stash是在队列头部插入数据 将stash还原到workspace1、git stash apply [stash] 12git stash apply stash@&#123;0&#125;将制定的stash记录还原到workspace，不删除stash记录 2、git stash pop 1将最后一个stash记录取出放到workspace，不删除stash记录 将stash 直接提交到localgit stash branch [stash] 123新建并checkout一个新分支&lt;branchname&gt;，分支开始于stash建立时的源提交，stash的变化作为熄灯呢工作区和暂存区。不制定stash时，使用最后一个stash，如果操作成功，则从stash删除本条记录。Demo:git stash branch stashCommit stash@&#123;0&#125;]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Git]]></title>
    <url>%2F2019%2F06%2F04%2FHello-Git%2F</url>
    <content type="text"><![CDATA[git学习地址 Git结构1Git分为5个工作区域分辨是stash、workspace、index、local、remote stash-暂存区1在处理其他事情时隐藏修改的地方 workspace1本地工作空间 index1你想提交的文件，在调用commit之前，你需要通过git add方法，把文件加入到这个区域 local1在项目下.git文件夹中，包含所有必要的repository文件 remote1您的项目的版本托管在Internet或网络上，确保您的所有更改都可供其他开发人员使用，默认名称origin]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin特性]]></title>
    <url>%2F2017%2F09%2F07%2Fkotlin%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[kotlin 其他特性解构声明123456789101112131415161718192021var user = DataUser("name",18)var (name,age) = user//这里实际操作是name = user.component1() age = user.component2()//name,age并不是通过名字映射，而是通过顺序，所以name对应的是component1()，//但是如果我们有时候不需要某个参数怎么办呢，使用 _ 代替变量名，而不能不填//这里我们只需要age就可以写成(_,age)class DataUser &#123; var name :String? = null; var age :Int? = null; //constructor([name : TypeName]*) : this([name : TypeName]*) constructor(name: String , age : Int) : this(name)&#123; println("0:"+System.nanoTime()) &#125; //定义了component1() ...componentN()，每个方法指定各自实际方法 //operator fun component1[N]() = FieldName // 如果使用了Data Class则会自动生成这些方法，不需要自己定义 //如果这个没有定义，也可以通过扩展函数定义 operator fun component1() = name operator fun component2() = age &#125; 类型检查与类型转换类型检查–&gt;is 与 !is 操作符123456//使用类型检查之后会自动进行类型转换fun demo(x: Any) &#123; if (x is String) &#123; print(x.length) // x 被自动转换为 String 类型 &#125;&#125; 类型转换 as as?(等于cast)1234567891011fun asDemo(x: Any) &#123; //如果x不是String类型会抛出异常 var a = x as String println(a.length) // 如果x不是Int类型b = null var b = x as? Int println(b) //如果x不是Int类型抛出异常 var c = x as Int println(c)&#125; this 表达式12345678910111213141516171819202122232425//this@class =&gt; Class.this//this@method =&gt; Int// this ==&gt; 看demo// this ==&gt;class A &#123; // 隐含的标签 @A inner class B &#123; // 隐含的标签 @B fun Int.foo() &#123; // 隐含的标签 @foo val a = this@A // 指向 A 的 this val b = this@B // 指向 B 的 this val c = this // 指向 foo() 函数的接受者, 一个 Int 值 val c1 = this@foo // 指向 foo() 函数的接受者, 一个 Int 值 val funLit = lambda@ fun String.() &#123; val d = this // 指向 funLit 的接受者 &#125; val funLit2 = &#123; s: String -&gt; // 指向 foo() 函数的接受者, 因为包含当前代码的 Lambda 表达式没有接受者 val d1 = this &#125; &#125; &#125;&#125; 相等判断12//结构相等 ==//引用相等 === 操作符重载操作符重载1这个比较复杂，自己查看这个就好了 null –&gt;? 操作符123456789101112131415161718fun main(args: Array&lt;String&gt;) &#123; //定义一个可空对象 var a : DataUser? = null //安全的调用可能为空的对象a?.name,如果失败会不调用(无返回值函数)，或者返回(有返回值函数)null //实际是通过if来操作 println(a?.name) println(a?.name?.length) //如果这个时候我们想给null一个默认值呢，就可以用到?: ，举个例子 println(a?.name ?: "my name is null") println(a?.name ?: "my name is null") //?: 后面还可以跟其他任意操作 a?.name ?: println("I'm in null Action")// a?.name ?: throw Exception("My Action")&#125;fun DataUser.println()&#123; println("I am user ,not null")&#125; !! 操作符 –&gt;如果为空则抛出NullPointException12var a : DataUser? = nulla!!.name 注解注解1annotation class AnnotationName 反射1234567891011121314151617181920212223242526//类引用(Class Reference)val c = MyClass::class//函数引用(Function Reference)::methodName//只能使用static，或者局部函数fun main(args: Array&lt;String&gt;) &#123; val cls = Reflect::class println(cls) testPrint(Reflect.Companion::test) testPrint(::test)&#125;fun testPrint(body : ()-&gt;Unit)&#123; body()&#125;fun test()&#123; println("method ref")&#125;class Reflect&#123; companion object &#123; fun test()&#123; println("method ref") &#125; &#125; fun test()&#123; println("method ref") &#125;&#125; 函数组合123456789101112131415161718fun main(args: Array&lt;String&gt;) &#123; var h = compose&lt;Int,String ,Int&gt;(::f,::g) println("main:$&#123;System.currentTimeMillis()&#125;") println(h.invoke(1))&#125;fun f(num :String) : Int&#123; println("f:$&#123;System.currentTimeMillis()&#125;") return num.toInt()+1&#125;fun g(num :Int) :String&#123; println("g:$&#123;System.currentTimeMillis()&#125;") return "$num"&#125;//实际就是把函数对Function当参数，fun &lt;A, B, C&gt; compose(f: (B) -&gt; C, g: (A) -&gt; B): (A) -&gt; C &#123; println("compose:$&#123;System.currentTimeMillis()&#125;") return &#123; x -&gt; f(g(x)) &#125;&#125; 类型安全的构建器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156//理念在 Groovy 开发社区非常流行. 使用构建器, 可以以一种半声明式的方式(semi-declarative way)来定义数据. 构建器非常适合于 生成 XML, 控制 UI 组件布局, 描述 3D 场景,//本质是通过constructor(init:&#123;&#125;)实现的fun main(args: Array&lt;String&gt;) &#123; val result = html &#123; head &#123; title &#123; +"XML encoding with Kotlin" &#125; &#125; body &#123; h1 &#123; +"XML encoding with Kotlin" &#125; p &#123; +"this format can be used as an alternative markup to XML" &#125; a(href = "http://lioil.com") &#123; +"Kotlin博客" &#125; p &#123; +"This is some" b &#123; +"mixed" &#125; +"text. For more see the" a(href = "http://lioil.com") &#123; +"Kotlin博客" &#125; +"project" &#125; p &#123; +"some text" &#125; p &#123; +"Command line arguments were:" ul &#123;for (arg in args) li &#123; +arg &#125;&#125; //命令行参数args &#125; &#125; &#125; println(result) //输出一个Html树形文档,输出结果在下文&#125;/*init参数本身就是一个函数,该函数类型是HTML.() -&gt; Unit,该函数带接收者是HTML类html &#123; //head和body是HTML的成员函数, this可以省略(this就是HTML类对象) this.head &#123; &#125; this.body &#123; &#125;&#125;*/fun html(init: HTML.() -&gt; Unit): HTML &#123; val html = HTML() html.init() return html&#125;/*String.unaryPlus()重载操作符+,作用就是把一个字符串包装到TextElement实例对象,并添加到children标签html集合,例如:title &#123; +"XML encoding with Kotlin" &#125;*/abstract class TagWithText(name: String) : Tag(name) &#123; operator fun String.unaryPlus() &#123; children.add(TextElement(this)) &#125;&#125;// 以下几个类,就是生成HTML标签元素class HTML() : TagWithText("html") &#123; fun head(init: Head.() -&gt; Unit) = initTag(Head(), init) fun body(init: Body.() -&gt; Unit) = initTag(Body(), init)&#125;class Head() : TagWithText("head") &#123; fun title(init: Title.() -&gt; Unit) = initTag(Title(), init)&#125;class Title() : TagWithText("title")class Body() : BodyTag("body")class UL() : BodyTag("ul") &#123; fun li(init: LI.() -&gt; Unit) = initTag(LI(), init)&#125;class B() : BodyTag("b")class LI() : BodyTag("li")class P() : BodyTag("p")class H1() : BodyTag("h1")class A() : BodyTag("a") &#123; public var href: String get() = attributes["href"]!! set(value) &#123; attributes["href"] = value &#125;&#125;interface Element &#123; fun render(builder: StringBuilder, indent: String)&#125;class TextElement(val text: String) : Element &#123; override fun render(builder: StringBuilder, indent: String) &#123; builder.append("$indent$text\n") &#125;&#125;@DslMarkerannotation class HtmlTagMarker/*自Kotlin 1.1起,引入了一种特殊机制,控制接收者作用域(Scope control: @DslMarker)不必用@HtmlTagMarker标注HTML或Head类,因为它们的超类/父类Tag已标注过!添加注解HtmlTagMarker之后,Kotlin编译器就知道哪些隐式接收者是同一个DSL,并且只允许调用最近层的接收者的成员html &#123; head &#123; head &#123; &#125; // 错误: head是外部接收者的成员 &#125; // ……&#125;注意:仍然可以调用外部接收者的成员,但必须明确指定该接收者:html &#123; head &#123; this@html.head &#123; &#125; // 可行 &#125; // ……&#125;*/@HtmlTagMarkerabstract class Tag(val name: String) : Element &#123; val children = arrayListOf&lt;Element&gt;() val attributes = hashMapOf&lt;String, String&gt;() protected fun &lt;T : Element&gt; initTag(tag: T, init: T.() -&gt; Unit): T &#123; tag.init() children.add(tag) return tag &#125; override fun render(builder: StringBuilder, indent: String) &#123; builder.append("$indent&lt;$name$&#123;renderAttributes()&#125;&gt;\n") for (c in children) &#123; c.render(builder, indent + " ") &#125; builder.append("$indent&lt;/$name&gt;\n") &#125; private fun renderAttributes(): String? &#123; val builder = StringBuilder() for (a in attributes.keys) &#123; builder.append(" $a=\"$&#123;attributes[a]&#125;\"") &#125; return builder.toString() &#125; override fun toString(): String &#123; val builder = StringBuilder() render(builder, "") return builder.toString() &#125;&#125;abstract class BodyTag(name: String) : TagWithText(name) &#123; fun b(init: B.() -&gt; Unit) = initTag(B(), init) fun p(init: P.() -&gt; Unit) = initTag(P(), init) fun h1(init: H1.() -&gt; Unit) = initTag(H1(), init) fun ul(init: UL.() -&gt; Unit) = initTag(UL(), init) fun a(href: String, init: A.() -&gt; Unit) &#123; val a = initTag(A(), init) a.href = href &#125;&#125; 在 Kotlin 中调用 Java 代码123451、去get,set2、返回值为 void -- Uint3、当 Java 标识符与 Kotlin 关键字重名时的转义处理 如foo.`is`(bar)4、在 Kotlin 中使用 JNI(Java Native Interface) --&gt;external fun foo(x: Int): Double5、在 伴生对象方法添加@Jvmstatic可以生成一个static桥接方法，调用伴生对象方法。在java中可以直接调用static方法 java和kotlin类型映射 在 Java 中调用 Kotlin 代码1//通过注解指定kt的class名称 @file:JvmName("ClassName")]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlinMethod]]></title>
    <url>%2F2017%2F09%2F06%2FkotlinMethod%2F</url>
    <content type="text"><![CDATA[method函数声明123[public] fun methodName([param: ClassName [,param: ClassName]*]*)[: ReturnClassName]&#123;&#125;fun add(second : Int) : Int&#123;&#125; 函数使用1[var varName] [: ClassName] = methodName([param [,param]*]) 中缀标记法(Infix notation)1234使用条件是成员函数, 或者是扩展函数只有单个参数使用 infix 关键字标记 Demo12345678910111213fun main(args: Array&lt;String&gt;) &#123; var str = "1" add "2" sub 1//输出2 println(str) println("1".add("3"))&#125;infix fun String.add(append : String): String&#123; return this.plus(append)&#125;infix fun String.sub(index : Int): String&#123; return this.subSequence(index,this.length).toString()&#125; 默认参数1234567891011class DefaultParam&#123; fun read(b: Array&lt;Byte&gt;, off: Int = 0, len: Int = b.size()) &#123;&#125;&#125;// 6 = 0b110//DefaultParam.read$default(new DefaultParam(), b, 0, 0, 6, (Object)null);//以下是伪代码DefaultParam param = DefaultParam();param.read(b[]);// 以read函数为例，有多个默认参数时可以通过参数名指定某个参数值param.read(b[],off = 1)param.read(b[],len = 3) 实际java代码12345678910111213 public final void read(@NotNull Byte[] b, int off, int len) &#123;&#125;// $FF: synthetic method// $FF: bridge methodpublic static void read$default(DefaultParam var0, Byte[] var1, int var2, int var3, int var4, Object var5) &#123; if((var4 &amp; 2) != 0) &#123; var2 = 0; &#125; if((var4 &amp; 4) != 0) &#123; var3 = ((Object[])var1).length; &#125; var0.read(var1, var2, var3);&#125; 思考1默认参数是通过添加static函数,实际调用static再桥接实际函数来实现，具体分两个static和非static static1234567fun methodName(param1,param2..)&#123;&#125;生成,会在参数后面加入2个参数，一个flag，一个obj，obj一般为null，如果有遇到可以联系我public final void methodNameread$default(param1,param2,..,int flag,Object obj)以fun read(b: Array&lt;Byte&gt;, off: Int = 0, len: Int = b.size())为例调用read(b[]) --&gt; read$default(b[],0,0,6,null),6 = 0b110,表示第一个参数有值，其他无值通过flat可以设置指定位置的值，比如read(b[],off = 1) --&gt;read$default(b[],0,0,4,null) b[] off len 0 1 1 123456789public static void read$default( Byte[] var1, int var2, int var3, int var4, Object var5) &#123; if((var4 &amp; 2) != 0) &#123;//--&gt;var4 &amp; 0b10 var2 = 0; &#125; if((var4 &amp; 4) != 0) &#123;//--&gt;var4 &amp; 0b100 var3 = ((Object[])var1).length; &#125; read(var1, var2, var3); &#125; 非static123456和static几乎一样，差别在第一个参数变成对象，具体看democlass DefaultParam&#123; fun read(b: Array&lt;Byte&gt;, off: Int = 0, len: Int = b.size()) &#123;&#125;&#125;DefaultParam().read() --&gt;实际调用如下public static void read$default(DefaultParam var0, Byte[] var1, int var2, int var3, int var4, Object var5) 单表达式函数(Single-Expression function)1fun double(x: Int) = x * 2 局部函数123456789fun move(x: Int) &#123; fun move(x: Int, y: Int) &#123; println("$x : $y") &#125; //建议参数都通过函数传递 move(x, 10)&#125;//实际会生成一个extends kotlin.jvm.internal.extends kotlin.jvm.internal.Lambda implements kotlin.jvm.functions.Function2 implements kotlin.jvm.functions.Function2的class，我叫他$1并带有一个INSTANCE对象//那么可以理解成，实际是使用了object :Lambda Function2 返回Unit123456//Unit 约等于 Voidfun returnNull() :Unit &#123;&#125;fun returnNull() :Unit &#123; return Unit&#125; 可变参数vararg12345678//vararg后面不能带参数，否则定的函数无法使用//和java可变参数一致fun &lt;T&gt; asList(vararg ts: T): List&lt;T&gt; &#123; val result = ArrayList&lt;T&gt;() for (t in ts) // ts 是一个 Array result.add(t) return result&#125; 尾递归函数(Tail recursive function)–&gt;不存在栈溢出(stack overflow)的风险1234//使用 tailrec 修饰符必须在最后一个操作中调用自己。在递归调用代码后面是不允许有其它代码的，并且也不可以在 try/catch/finall 块中进行使用。当前的尾递归只在 JVM 的后端中可以用//意味着很多操作都用不了，使用场景不多tailrec fun findFixPoint(x: Double = 1.0): Double = if (x == Math.cos(x)) x else findFixPoint(Math.cos(x)) Lambda 表达式123456789101112//不带返回值的 var list = arrayListOf&lt;Int&gt;(1,2,3) //单个参数默认名字是it list.forEach &#123; it -&gt; println(it) &#125; //实际是生成一个Function对象，调用invote函数，使用inline的话不会生成对象，底层代码做了优化 //带返回值的 fun Int.highAction(name:(Int) -&gt; Int) &#123; println(name(this)) &#125; //这里注意，多个操作时，return 之前有其他操作需要加 ; ，return@函数名称 //如果是单个操作，如1.highAction &#123; 1 &#125; 就不需要return 1.highAction &#123; println(it); return@highAction 1 &#125; 高阶函数1234567891011121314151617181920212223242526272829303132//body 名称可以自己定，格式为name:(params) -&gt; ReturnType// 不需要返回则用Uint//body只有一个参数时默认用it fun &lt;T&gt; lock(lock: Lock?, body: () -&gt; T): T &#123; lock?.lock() try &#123; return body() &#125; finally &#123; lock?.unlock() &#125;&#125;// 调用fun main(args: Array&lt;String&gt;) &#123;//调用lambda.实际是生成一个Function对象，调用invote函数 lock(null,&#123; println("action in Lock")&#125;) // ::staticMethodName,直接将函数名传入调用函数，原理同上 lock(null, ::actionInLock) lock(null, fun()&#123; println("action in Anonymous ") &#125;)&#125;fun actionInLock()&#123; println("action in Method")&#125;fun Int.highAction(name:(Int) -&gt; Unit)&#123; name(this);&#125; 1思考，有这个函数可以做很多事情，比如资源的释放，还有时间统计等等，都可以在这里轻松解决，而不需要添加太多代码 匿名函数(Anonymous Function)12345678910111213//配合高级函数使用fun(x: Int, y: Int): Int = x + y``` ### 闭包```kotlin//实际都是生成了对象，然后使用实际对象操作 var ints = arrayOf(1,2,3) var sum = 0 ints.filter &#123; it &gt; 0 &#125;.forEach &#123; sum += it &#125; print(sum) 带有接受者的函数字面值123// 通过生成Function class，调用invoke val sum = fun Int.(other: Int): Int = this + other 1.sum(2); 内联函数 inline 12345678910111213141516171819202122//内联函数可以讲函数内代码提到执行地方，从而避免产生太多的函数，顺带提升运行效率，但是内联使用有限制条件//函数内联也许会导致编译产生的代码尺寸变大, 但如果我们使用合理(不要内联太大的函数), 可以换来性能的提高, //以inline fun &lt;T&gt; lock(lock: Lock?, body: () -&gt; T): T &#123;&#125;为例，加了inline之后反编译的代码中就没有lock这个函数，而是将lock的整个代码放到调用地方//如果 inline函数调用包含inline则外层inline失效，举个栗子 inline fun inlineAction()&#123; lock(null,&#123; println("action in inlineAction")&#125;) &#125; inline fun &lt;T&gt; lock(lock: Lock?, body: () -&gt; T): T &#123;//伪代码&#125; //这时候调用inlineAction()，这个方法并不多消失 //在局部函数中，非内联函数为外层函数return，而内联可以 fun foo() &#123; ordinaryFunction &#123; return // 错误: 这里不允许让 `foo` 函数返回 &#125; &#125; fun foo() &#123; inlineFunction &#123; return // OK: 这里的 Lambda 表达式是内联的 &#125; &#125; 具体化的类型参数123456//reified 必须配合inline使用//不知道干啥用的，目前就看到reified之后可以使用::class,::class.java,如果不加，没法使用 //::class可以获取T的真实类型，inline fun &lt;reified T&gt; getRealType( t : T) : Unit&#123; println(T::class)&#125;]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlinGeneric]]></title>
    <url>%2F2017%2F09%2F04%2FkotlinGeneric%2F</url>
    <content type="text"><![CDATA[泛型普通泛型–&gt;和java一样1class Box&lt;T&gt; 类型变异 –&gt;上下边界123456789101112131415//生产者只能取出(get)//消费者可写入取出，取出只能是object//生产者(Producer)对应 Extends, 消费者(Consumer) 对应 Super.// in --&gt;只能被消费 = super// out --&gt;生产这 == extend var extendsList : ArrayList&lt;out String&gt; = ArrayList(arrayListOf("1","2","3"))var superList : ArrayList&lt;in String&gt; = ArrayList(arrayListOf("1","2","3"))extendsList.get(0)//无法写入// extendsList.add("4")println(extendsList[0])superList.add("5")println(superList[3]) 星号投射–&gt; &lt;*&gt; 并不知道怎么用，有知道的朋友可以联系我1234567891011121314//如果参数本身添加了in 或者out，这个时候无法直接将该参数当做Any传给下一个函数，举个栗子fun main(args: Array&lt;String&gt;) &#123; var strArr : Array&lt;out String&gt; = arrayOf("1") var strArr2 : Array&lt;in String&gt; = arrayOf("1") //这个调用就会报错，需要将testAny的参数对应改成out或者in， // 然而这个并不灵活,改成in 或者out其中一个，另外一个就无法使用，这个时候可以使用* //正确做法fun testAny(any : Array&lt;*&gt;) testAny(strArr) testAny(strArr2)&#125;fun testAny(any : Array&lt;Any&gt;)&#123; println(any)&#125; 泛型约束12//最常见的约束是 上界(upper bound), 与 Java 中的 extends 关键字相同fun &lt;T : Comparable&lt;T&gt;&gt; sort(list: List&lt;T&gt;)]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlinproperty]]></title>
    <url>%2F2017%2F09%2F03%2Fkotlinproperty%2F</url>
    <content type="text"><![CDATA[kotlin property属性12345678910111213141516//class中默认为private，即使加了public也没用，并自动生成getter，settervar &lt;propertyName&gt;: &lt;PropertyType&gt; [= &lt;property_initializer&gt;] [private] [&lt;getter&gt;] [private] [&lt;setter&gt;] // Demo class Addr &#123; var age: String? = null var name: String? = null get() = name set(value) &#123; // 实际是调用set，会造成死循环,用field代替当前属性 field = "$value-from_set" println(field)&#125; &#125; 常量12//这个只能放伴生对象const val &lt;propertyName&gt;: &lt;PropertyType&gt; [= &lt;property_initializer&gt;] 延迟初始化1234567//private var name2 : String? = null//publiclateinit var name:Stringval lazyValue: String by lazy &#123; "lazyValue"&#125; [自欺欺人的属性覆盖]-&gt;委托属性1234567891011121314class Example &#123; var p: String by Delegate()&#125;class Delegate &#123; var pro : String = "" operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123; return pro &#125; operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123; pro = value &#125;&#125; 可观察属性12345class Change&#123; var change : String by Delegates.observable("init")&#123; property, oldValue, newValue -&gt; println("$&#123;property.visibility&#125;-$oldValue,$newValue") &#125;&#125; map映射12345678910fun main(args: Array&lt;String&gt;) &#123; var user = MutableUser(mutableMapOf("name" to "test", "age" to 1)) println(user.name) println(user.age)&#125;class MutableUser(val map: MutableMap&lt;String, Any?&gt;) &#123; var name: String by map var age: Int by map&#125;]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlinclass]]></title>
    <url>%2F2017%2F09%2F03%2Fkotlinclass%2F</url>
    <content type="text"><![CDATA[kotlin class类结构 &amp; 构造方法1234567891011121314151617181920212223//默认是final，添加open表示非final，可以继承//主构造方法,不建议这么写，有主构造方法时子类无法调用次要构造方法//[open ][public] class DataUser [constructor]()open class DataUser constructor(name : String) &#123; init &#123; //初始化-在super()之后调用 println("1:"+System.nanoTime()) &#125; // : this() 调用自身构造方法 //次要构造方法 //constructor([name : TypeName]*) : this([name : TypeName]*) constructor(name: String , age : Int,parent: DataUser) : this(name)&#123; //在init之后调用 println("0:"+System.nanoTime()) &#125;&#125;class ChildUser(name: String): DataUser(name) &#123; // 子类只能调用父类主构造方法// constructor(name: String, age : Int) : super(name, age)&#125;kotlin 有一个主构造方法多个次要构造方法,子类构造方法无法使用父类次要构造方法 open –&gt; 去掉final12345//在class上添加，允许继承open class DataUser&#123;//在方法上添加，允许重写，重写需要加override open fun noFinal()&#123;&#125;&#125; 构造方法 &amp; 继承12345678open class DataUser &#123; constructor(name: String) : this(name) constructor(name: String , age : Int,parent: DataUser) : this(name)&#125;class ChildUser : DataUsers&#123; constructor(name: String) : super(name) constructor(name: String , age : Int,parent: DataUser) : super(name)&#125; 重写父类方法123456789//继承class SuperClass &#123; open fun get()&#125;class ChildClass : SuperClass &#123; // 重写必须带override override fun get()&#125; 自欺欺人的属性覆盖12345678910//实际上编译之后属性并没有改变，只是复写了get方法，覆盖了get,不信你用super.x试试interface Foo &#123; val count: Int&#125;class Bar1(override val count: Int) : Fooclass Bar2 : Foo &#123; override var count: Int = 0&#125; 接口1234567//方法可以有默认实现,实际是写了默认实现类interface Foo &#123; fun f() fun b()&#123; printlb("default") &#125;&#125; 枚举123456//定义和java一样enum class Direction &#123; NORTH, SOUTH, WEST, EAST&#125;//EemuClass.valueOf("NORTH")var dir = Direction.valueOf("NORTH") 多继承1234567891011121314151617open class A &#123; open fun f() &#123; print("A") &#125; fun a() &#123; print("a") &#125;&#125;interface B &#123; fun f() &#123; print("B") &#125; // 接口的成员默认是 'open' 的 fun b() &#123; print("b") &#125;&#125;class C() : A(), B &#123; // 编译器要求 f() 方法必须覆盖: override fun f() &#123; super&lt;A&gt;.f() // 调用 A.f() super&lt;B&gt;.f() // 调用 B.f() &#125;&#125; 单例 –&gt;通过伴生对象实现123456789101112//使用伴生对象class Singlton private constructor()&#123; companion object &#123; val INSTANCE = Singlton() &#125;&#125;//使用object表达式 object Inner2 : Inner&#123; override fun action() &#123; &#125;&#125; 匿名内部类 –&gt; object : ClassName construstor()1234567891011fun main(args: Array&lt;String&gt;) &#123; var inner : Inner = object : Inner&#123; override fun action() &#123; println("action"); &#125; &#125; inner.action()&#125;interface Inner&#123; fun action()&#125; 封闭类(Sealed Class)123456789101112//== abstract + [private constructor] //可以使用内部sealed class name&#123; constructor()&#123; print(1) &#125; //非static var a : String? = null //public static final class Const : SealedTest() class Const2 : SealedTest()&#125; 伴生类 (companion object)1234567891011121314151617//会生成一个public static final class Companion,并且构造方法私有化class Test&#123;// Test会持有一个public static final Companion对象 companion object &#123; //属性会外提到Test const val i = 1; var j = 2; fun get() : Int = 3 &#125; fun main()&#123; println(i) //实际是调用Companion对象的.getJ() println(j) println(get()) &#125;&#125; 权限12345在top-level,包括包名名下如果你不指定任何可见度修饰符, 默认会使用 public, 其含义是, 你声明的东西在任何位置都可以访问;如果你将声明的东西标记为 private, 那么它将只在同一个源代码文件内可以访问;如果标记为 internal, 那么它将在同一个模块(module)内的任何位置都可以访问;对于顶级(top-level)声明, protected 修饰符是无效的. 12345private class PrivateTest&#123;&#125;open class ProtectedTest&#123;&#125;internal class InternalTest&#123;&#125;public class PublicTest&#123;&#125;class DefaultTest&#123;&#125; 12345在class和interface内private 表示只在这个类(以及它的所有成员)之内可以访问;protected — 与 private 一样, 另外在子类中也可以访问;internal — 在 本模块之内, 凡是能够访问到这个类的地方, 同时也能访问到这个类的 internal 成员;public — 凡是能够访问到这个类的地方, 同时也能访问这个类的 public 成员. 123456789101112131415161718192021222324open class Outer &#123; private val a = 1 protected open val b = 2 internal val c = 3 val d = 4 // 默认为 public protected class Nested &#123; public val e: Int = 5 &#125;&#125;class Subclass : Outer() &#123; // a 不可访问 // b, c 和 d 可以访问 // Nested 和 e 可以访问 override val b = 5 // 'b' 可见度为 protected&#125;class Unrelated(o: Outer) &#123; // o.a, o.b 不可访问 // o.c 和 o.d 可以访问(属于同一模块) // Outer.Nested 不可访问, Nested::e 也不可访问&#125; 扩展函数12345//实际操作是底层持有了调用的对象fun TpyeName.method()&#123;&#125;//demo== int add(int $receiver, int other)//加？表示可空 fun Int?.add(other : Int): Int&#123;&#125; 扩展属性(Extension Property)1234//实际操作是底层持有了调用的对象,实际也是添加了get方法// 对于扩展属性不允许存在初始化器val &lt;T&gt; List&lt;T&gt;?.lastIndex: Int get() = size - 1 对象表达式 –&gt;用于函数内，立即执行1234567891011//1、匿名内部类 object className demo在上面var inner : Inner = object : Inner&#123; override fun action() &#123; println("action") &#125; &#125;//2、 不写基类默认基础objectval adHoc = object &#123; var x: Int = 0 var y: Int = 0&#125; 对象声明 –&gt;用户方法外，延迟执行123456789101112//对象申明都是单例，并且直接使用类名就会自动调用单例对象//比如 Adapter.setData() 实际调用Adapter.INSTANCE.setData() //对象声明：调用到才会初始化object Adapter &#123; fun setData() &#123;&#125; var count:Int = 0&#125;//对象申明可以继承和实现类，但是最后基类不要有主要构造，或者主要构造中不需要传值object Inner2 : Inner&#123; override fun action() &#123; &#125;&#125; 类委托12345678910111213//Derived 实现了Base，并将事情委托给BaseImpl2interface Base &#123; fun print()&#125;class BaseImpl2(val x: Int) : Base &#123; override fun print() &#123; print(x) &#125;&#125;class Derived(b: Base) : Base by bfun main(args: Array&lt;String&gt;) &#123; val b = BaseImpl2(10) Derived(b).print() // 打印结果为: 10&#125;]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlinBase]]></title>
    <url>%2F2017%2F09%2F03%2FkotlinBase%2F</url>
    <content type="text"><![CDATA[kotlin基础语法中的坑 1这里主要是写一些kotlin和java不一样的东西，和一些坑 详细中文文档 Char不是数值类型不支持八进制kotlin 基础类型会自动拆装箱== 等于java中equals ,=== 表示全等不同基础类型需要显示转换运算符1val x = (1 shl 2) and 0x000FF000 以下是位运算符的完整列表(只适用于 Int 类型和 Long 类型): shl(bits) – 带符号左移 (等于 Java 的&lt;&lt;) shr(bits) – 带符号右移 (等于 Java 的 &gt;&gt;) ushr(bits) – 无符号右移 (等于 Java 的 &gt;&gt;&gt;) and(bits) – 按位与(and) or(bits) – 按位或(or) xor(bits) – 按位异或(xor) inv() – 按位取反 原生字符串–&gt;就是帮你做了转义的工作1234567fun originString()&#123; val text = """ for (c in "foo") print(c)""" println(text)&#125; 输出123for (c in &quot;foo&quot;)print(c) 字符串模板12345var i = 1//第一种var content = "i = $i"//第二种，这里可以写表达式var content2 = "i = $&#123;i+1&#125;" 包（import）import com.demo.data.User as UserInfo123import com.demo.data.User as UserInfovar user : UserInfo = UserInfo() if1234// if 作为表达式使用//等价于 var var1000 : [typeName] = null if (var1000 = a)&#123; var1000 = a &#125; else&#123;var1000 = b] mac = var1000// while try 之类的可以直接赋值也是这个原理val max = if (a &gt; b) a else b when1when 实际操作是if else 所以理论上if else支持的，when都支持 While do while和java一样for 支持多种实现12345678910// 下标从1-5//for (var in range [step Int])for (x in 1..5)// 从1-4，不包含5，部分会生成Range对象，导致额外开销//for (var in 1 until 5 [step Int])for (x in 1 until 5)//for (var in 5 downTo 1 [step Int])for (x in 5 downTo 1) //for (i in array.indices) in 后面实际上跟的Range,底层是用while(true)实现for (i in array.indices) 返回与跳转 –&gt; return ,break,continuereturn和break支持标签 12345678910// 这里是for是用while实现，和java实现一样 label@ for (i in 1..5)&#123; print(i) for (j in 1..2)&#123; if (3==i)&#123; break@label &#125; &#125; &#125; println() 12345678//在内部方法跳出，这里使用了内联，最后也是通过代码优化，判断条件执行fun labelReturn()&#123; var ints = arrayOf(1,2,3) ints.forEach loop@ &#123; if (it == 0) return@loop print(it) &#125;&#125;]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
</search>
